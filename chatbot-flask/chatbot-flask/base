from flask import Flask, request, jsonify
from flask_cors import CORS
import cohere
import logging
import re
import os
import json
from typing import List, Dict, Optional, Tuple

# --- Configuration Flask & CORS ---
app = Flask(__name__)
CORS(app, 
     origins=['http://localhost:4200', 'http://127.0.0.1:4200'],
     methods=['GET', 'POST', 'OPTIONS'],
     allow_headers=['Content-Type', 'Authorization'],
     supports_credentials=True)
# --- Configuration Logging ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# --- Connexion √† Cohere ---
try:
    COHERE_API_KEY = os.getenv("COHERE_API_KEY", "2EOXEMW2uXH1UelILUxrQE0i2s6TzCLbt64wvfzc")
    co = cohere.Client(COHERE_API_KEY)
    logger.info("Connexion √† l'API Cohere r√©ussie.")
except Exception as e:
    logger.error(f"Erreur de connexion √† Cohere: {e}")
    raise

# --- Chargement des donn√©es OSS ---
def load_oss_data(file_path: str = 'oss_structured_data.json') -> List[Dict]:
    if not os.path.exists(file_path):
        logger.error(f"Fichier {file_path} introuvable.")
        raise FileNotFoundError(f"Le fichier {file_path} n'existe pas.")

    with open(file_path, 'r', encoding='utf-8') as f:
        data = json.load(f)

    if not isinstance(data, list):
        raise ValueError("Les donn√©es doivent √™tre une liste.")

    for item in data:
        if not all(k in item for k in ['page', 'url', 'content']):
            raise ValueError("Chaque item doit contenir 'page', 'url' et 'content'.")

    logger.info(f"Donn√©es OSS charg√©es depuis {file_path}")
    return data

# --- Initialisation des donn√©es ---
try:
    OSS_DATA = load_oss_data()
    for page in OSS_DATA:
        page_number = page.get('page')
        if isinstance(page_number, int):
            if page_number == 1:
                page['keywords'] = ["pr√©sentation", "mission", "expertise", "pays membres", "observatoire"]
            elif page_number == 2:
                page['keywords'] = ["biodiversit√©", "copernicea", "√©cosyst√®me", "nature"]
            elif page_number == 3:
                page['keywords'] = ["climat", "dressea", "adaptwap", "s√©cheresse", "m√©t√©o"]
            elif page_number == 4:
                page['keywords'] = ["eau", "restore naw", "ittas", "smas", "ressources hydriques", "hydrique"]
        else:
            logger.warning(f"Page number non valide : {page_number}")
except Exception as e:
    logger.error(f"Erreur de chargement des donn√©es OSS: {e}")
    OSS_DATA = []

# --- Extraction r√©cursive du texte contenu dans le champ 'content' ---
def extract_text_from_content(content) -> str:
    """
    Fonction r√©cursive pour extraire tout le texte d'un champ content
    qui peut √™tre une cha√Æne, une liste de cha√Ænes ou une liste de dicts avec 'content' √† l'int√©rieur.
    """
    if isinstance(content, str):
        return content
    elif isinstance(content, list):
        texts = []
        for item in content:
            texts.append(extract_text_from_content(item))
        return " ".join(texts)
    elif isinstance(content, dict):
        # Si c'est un dict avec un champ 'content'
        return extract_text_from_content(content.get('content', ''))
    else:
        return ""

# --- Nettoyage & Formatage de la r√©ponse OSS ---
def format_oss_response(page: Dict, user_query: str = "") -> Tuple[str, str]:
    """
    Am√©lioration du formatage des r√©ponses avec :
    - Titre clair
    - Contenu pertinent en fonction de la requ√™te
    - Mise en forme Markdown
    - Source claire
    Retourne un tuple (r√©ponse courte, r√©ponse compl√®te)
    """
    # Extraction des m√©tadonn√©es
    title = page.get('url', '').split('/')[-1].replace('-', ' ').title() if page.get('url') else "Titre inconnu"
    raw_content = page.get('content', '')
    source_url = page.get('url', '')
    
    # Extraction du texte
    full_text = extract_text_from_content(raw_content)
    
    # Nettoyage du texte
    full_text = re.sub(r'(D√©tail du projet\s*)+', '', full_text, flags=re.IGNORECASE)
    full_text = re.sub(r'(Voir tous les projets\s*)+', '', full_text, flags=re.IGNORECASE)
    full_text = re.sub(r'\s+', ' ', full_text).strip()
    
    # Highlight des termes de recherche
    if user_query:
        query_words = re.findall(r'\w+', user_query.lower())
        for word in query_words:
            if len(word) > 3:  # On ignore les mots trop courts
                full_text = re.sub(
                    f'({word})', 
                    r'**\1**', 
                    full_text, 
                    flags=re.IGNORECASE
                )
    
    # Cr√©ation des versions courte et longue
    sentences = re.split(r'(?<=[.!?])\s+', full_text)
    
    # Version courte (3 premi√®res phrases ou 200 premiers mots)
    short_response = ' '.join(sentences[:3]) if len(sentences) > 2 else ' '.join(full_text.split()[:200])
    
    # Formatage Markdown
    source = f"\n\nüîó [Source originale]({source_url})" if source_url else ""
    
    formatted_short = f"### üìå {title}\n\n{short_response}{source}"
    formatted_full = f"### üìå {title}\n\n{full_text}{source}"
    
    return (formatted_short, formatted_full)

# --- Recherche par correspondance ---
def find_best_match(user_input: str) -> Optional[Tuple[str, str]]:
    if not OSS_DATA:
        return None

    input_lower = user_input.lower()

    # Recherche par mots-cl√©s
    keyword_matches = []
    for page in OSS_DATA:
        keywords = page.get('keywords', [])
        if any(k.lower() in input_lower for k in keywords):
            keyword_matches.append(page)
    
    if keyword_matches:
        # On prend la page avec le plus de mots-cl√©s correspondants
        best_page = max(
            keyword_matches,
            key=lambda p: sum(1 for k in p['keywords'] if k.lower() in input_lower)
        )
        return format_oss_response(best_page, user_input)

    # Recherche par titre de page
    for page in OSS_DATA:
        url = page.get('url', '')
        page_title = url.split('/')[-1].replace('-', ' ').lower() if url else ''
        if page_title in input_lower:
            return format_oss_response(page, user_input)

    # Recherche par contenu textuel
    best_match, highest_score = None, 0
    input_words = re.findall(r'\w+', input_lower)
    for page in OSS_DATA:
        raw_content = page.get('content', '')
        content_text = extract_text_from_content(raw_content).lower()

        match_count = sum(1 for word in input_words if word in content_text)
        if match_count > highest_score:
            highest_score = match_count
            best_match = page

    if highest_score >= 2 and best_match:
        return format_oss_response(best_match, user_input)

    return None

# --- G√©n√©ration via Cohere ---
def generate_gpt_response(user_input: str, context: List[str]) -> str:
    try:
        context_prompt = "\n".join(
            [f"Utilisateur: {c}" if i % 2 == 0 else f"Assistant: {c}" for i, c in enumerate(context[-6:])]
        )
        prompt = f"""{context_prompt}

Contexte suppl√©mentaire:
L'Observatoire du Sahara et du Sahel (OSS) est une organisation internationale √† caract√®re scientifique et technique qui ≈ìuvre pour la gestion durable des ressources naturelles dans les r√©gions arides.

Utilisateur: {user_input}
Assistant:"""

        response = co.generate(
            model='command-r-plus',
            prompt=prompt,
            max_tokens=300,
            temperature=0.5,
            stop_sequences=["Utilisateur:"],
            preamble="""Vous √™tes un assistant expert de l'Observatoire du Sahara et du Sahel (OSS). 
R√©pondez de mani√®re pr√©cise et professionnelle, en utilisant un langage clair et concis.
Si vous ne connaissez pas la r√©ponse, dirigez l'utilisateur vers le site officiel de l'OSS."""
        )

        output = response.generations[0].text.strip()
        output = re.sub(r'\s+', ' ', output).strip()

        if not output or len(output.split()) < 3:
            return "Je n'ai pas trouv√© d'information pr√©cise √† ce sujet. Pour plus de d√©tails, vous pouvez consulter le site officiel de l'OSS : https://www.oss.org.tn"

        return output

    except Exception as e:
        logger.error(f"Erreur Cohere: {e}")
        return "Une erreur est survenue lors de la g√©n√©ration de la r√©ponse. Veuillez reformuler votre question."

# --- Choix final de r√©ponse ---
def generate_response(user_input: str, context: List[str]) -> Dict:
    oss_response = find_best_match(user_input)
    
    if oss_response:
        logger.info("R√©ponse extraite des donn√©es OSS.")
        short_response, full_response = oss_response
        return {
            "response": short_response,
            "full_response": full_response,
            "source": "oss_data",
            "context": context + [user_input, short_response]
        }
    
    logger.info("Aucune correspondance trouv√©e, appel √† Cohere.")
    gpt_response = generate_gpt_response(user_input, context)
    return {
        "response": gpt_response,
        "full_response": gpt_response,
        "source": "cohere",
        "context": context + [user_input, gpt_response]
    }

# --- Route principale ---
@app.route('/chat', methods=['POST'])
def chat():
    try:
        data = request.get_json(force=True)
        user_input = data.get('message', '').strip()
        context = data.get('context', [])

        if not user_input:
            return jsonify({
                "response": "Votre message est vide. Pouvez-vous reformuler ?",
                "full_response": "Votre message est vide. Pouvez-vous reformuler ?",
                "source": "system"
            })

        logger.info(f"Message re√ßu : {user_input}")

        response_data = generate_response(user_input, context)

        return jsonify(response_data)

    except Exception as e:
        logger.error(f"Erreur dans la route /chat: {e}")
        return jsonify({
            "response": "Une erreur est survenue sur le serveur.",
            "full_response": "Une erreur est survenue sur le serveur.",
            "source": "system"
        }), 500

# --- Point d'entr√©e ---
if __name__ == '__main__':
    app.run(debug=True, port=5000)
